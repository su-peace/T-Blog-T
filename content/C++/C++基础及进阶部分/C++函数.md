---
date: 2026-01-19
tags:
  - 计算机科学与技术
  - 语言
  - 学习
---
# 函数指针

>函数指针，顾名思义，也就是指向一个函数的指针，可用于在一个函数中调用另一个函数

- 函数地址的获取
	- 函数地址的获取**只需要使用函数名即可代表函数地址**
	- **例如：** 编写了一个函数`add()`，那么，该函数的地址可以用`add` 来表示，与之对应的，`add()` 代表的是该函数的返回值

<br>

- 声明函数指针
	- 与普通指针类似，但是，声明函数指针时，**需要指定指针指向的函数类型，并且需指定函数的特征标**（参数列表） 
	- **例如：** 声明一个函数指针是这样的：`double (*pa)(int a,int b)` ，假设一个函数为`add(int a,int b)`， 接下来将函数地址和函数指针对应上：`pa = &add` 或`pa = add` 
	- **注意：** 为保证函数优先级，在声明时**应使用括号将`*pa` 括起来，写成`(*pa)`；** 若是不括，写成`*pa`，这代表函数`pa()`的是一个返回类型为地址的函数
	- 调用函数的时候也可以这样使用：原本为`add(a,b)`，将`pa` 指向`add`函数之后，可以使用`pa(a,b)` 或`(*pa)(a,b)` 达到相同的效果

<br>

以下是示例： 

>[!code] 
>```Cpp
>#include <iostream>
>using namespace std;
>int add(int a,int b){
>	return a + b;
>}
>int mult(int a,int b){
>	return a * b;
>}
>void deal(int a,int b,int (*pa)(int , int)){
>	cout<<"以下是调用函数处理的结果"<<(*pa)(a,b)<<endl;
>}
>int main()
>{
>	int a = 0,b = 0;
>	cin>>a>>b;
>	cout<<"这是调用加法的结果：";
>	deal(a,b,add);
>	cout<<"这是调用乘法的结果：";
>	deal(a,b,mult);
>	return 0;
>}
>```
>
>>**对于特征标：** 如代码中所示，只需标注数据类型即可，如`(*pa)(int,int)`

<br>

### 深入探讨函数指针

```cpp
const double * f1(const double ar[],int n);
const double * f2(const double [],int);
const double * f3(const double *,int);
```

以上三个函数的特征标看似不同，实际是相同的
- `const double ar[]` 与`const double *ar`的含义完全相同
- 可以将`const double ar[]`简化为`const double []`，将`const double *ar`简化为`const double *`
- 在函数定义中需要提供标识符，因此**在定义中不能将特征标简化，而在函数指针中使用可以简化使用** 

<br>

- 对于函数而言，也存在一个与数组相同意义的**函数指针数组**
	- 例如，假设要声明一个包含三个函数指针的数组，可以这样声明`const double *(*pa[3]) (const double *,int) = {f1,f2,f3};`，也可以简化为`auto pa = {f1,f2,f3};`
	- **为什么这样定义：** 运算符<kbd>[]</kbd>的优先级高于<kbd>*</kbd>，若定义为`*pa[3]`，则代表的是包含三个指针的数组
	- `**&pa == *pa == pa[0]` 

<br>

### 补充内容

- C++在C++11标准中加入`auto`关键字，用于**自动类型推断**
	- 例如：`auto i = 10` 将自动将<kbd>i</kbd>推导为<kbd>int</kbd>类型
	- 在函数指针中将会更加方便，例如：`const double * (*p1)(const double *,int) = f1`，在使用`auto`关键字时，可以这样使用`auto p1 = f1` 

<br>

- 存在<kbd>function</kbd>头文件包含<kbd>function</kbd>函数，这是一个**函数包装器模板**，提供了一个统一的方式用于保存、复制和调用任何可调用对象，可以将其理解为**超级函数指针** ，具体内容点击[[function头文件|此处查看]] 

<br>

- **特征标：** 特征标通常指的是类型特征，包括了返回类型、参数类型列表、参数数量等

# 内联函数

- 简要介绍：内联函数的作用是在编译时将函数调用**替换为函数体本身** 
	- 内联函数与常规函数一样，都是按值来传递参数

<br>

- 如何使用：
	- 在函数声明前加上关键字<kbd>inline</kbd> 
	- 在函数定义前加上关键字<kbd>inline</kbd> 

例如：
```cpp
#include <iostream>
using namespace std;
inline double add(int a,int b);
int main()
{
	int a = 0,b = 0;
	cin>>a>>b;
	cout<<"使用内联函数来处理数据得到："<<add(a,b)<<endl;
	return 0;
}
inline double add(int a,int b){
	return a + b;
}
```

<br>

# 引用变量

C++新增一种复合类型：引用变量，作用是为已定义的变量创建一个别名
- 使用<kbd>&</kbd>创建引用变量
- 例如：`int & hat = cap;`

在指针中我们使用<kbd>&</kbd>来得到一个变量地址，但在这里，上述的例子中，<kbd>&</kbd>的作用只是创建别名，之后`hat`和`cap`都将指向相同的值和地址 

<br> 

不允许的：`int &hat ;int cap;hat = cap;`，这样的操作是不允许的

- 在C++中，引用经常被用作函数参数，这是因为C++引入了一个新特性：**按引用传递**
	- 引用变量常常用作函数参数，是因为引用变量和指针类似，但是相较于指针更安全，无需担心空指针的情况
	- **不能将表达式传递给引用变量**

下面是使用引用变量来实现交换数字的操作：
```cpp
#include <iostream>
using namespace std;
void myswap(int & n1,int & n2);
int main()
{
	int a = 0,b = 0;
	cout<<"输入整数a和b"<<endl;
	cin>>a>>b;
	cout<<"下面使用引用变量来实现两数字的交换"<<endl;
	myswap(a,b);
	cout<<"a = "<<a<<",b = "<<b<<endl;
	return 0;
}
void myswap(int & n1,int & n2)
{
	int temp = n1;
	n1 = n2;
	n2 = temp;
}
```

<br>

- 将**引用用于结构**
	- 若是要将结构用于引用，只需在编写函数原型时，在函数中将指向该结构的引用作为参数即可
	- 例如：假设有一个名为<kbd>free_throws</kbd>的结构，则应当在编写函数原型中这样写：`void set_pc(free_throws & ft)` ，但需注意，这样的操作**会修改结构中的原始数据** ，若是不希望修改，则可以这样操作`viod display(const free_throws & ft)` 
	- **注意：** 因避免返回函数终止时不再存在的内存单元的引用，即**返回一个局部的引用变量是不可取的** 
		- 这是因为函数返回时，这个局部变量占用的栈内存将被标记为可用，这意味着后续的操作中，这部分内存可能被其他函数调用，进而导致数据被覆盖
		- 会导致程序难以调试，使得程序看起来正常，实际上会随机崩溃 

<br>

- 将**引用用于类对象**
	- 将类对象传递给函数时，C++的常用做法为使用引用，这样处理可以使得<kbd>string</kbd>、<kbd>ostream</kbd>、<kbd>istream</kbd>、<kbd>ofstream</kbd>和<kbd>ifstream</kbd>等类的对象作为参数 
	- 能将特性从一个类传递给另一个类的语言特性被称为**传递**，更多内容参考详述章节：[[C++类]] 

>[!Tip] 什么时候使用引用参数
>1. 需要修改调用函数中的数据对象时
>2. 通过传递引用而不是整个数据对象，可以提高程序运行速度
>
>以下是一些建议：
>
>对于不修改值，只是传递
>>1. 数据对象小，选择按值传递
>>2. 数据对象是数组，使用指针，若是不想修改原始数据的值，可以将指针声明为<kbd>const</kbd>
>>3. 数据对象为较大的结构，使用<kbd>const</kbd>指针或<kbd>const</kbd>引用，可以提高效率
>>4. 数据对象为类对象，使用<kbd>const</kbd>引用
>
>对于修改值
>>1. 如果数据是内置数据类型，使用指针
>>2. 如果数据对象是数组，使用指针
>>3. 如果数据对象是结构，使用引用或指针
>>4. 如果数据对象是类对象，使用引用


### 补充内容

- 按值传递：传递时将会复制提供的值，创建一个副本来进行处理
- 如果要对数组使用引用类型，也就是创建一个引用类型的数组，而不是数组中的元素为应用类型
	- 那么可以这样做`int arr = {1,3,5,7,9};int (&ref)[5] = arr;`
- **注意： 引用必须绑定到已存在的对象** 

<br>

# 默认参数

- 简要介绍：默认参数指的是当函数调用中省略了实参的时候，自动使用的一个值
	- 例如：`void wow(int n)`，当没有给任何一个参数时，n将等于默认值，假设默认值为1，则调用`wow()`相当于调用`wow(1)`


- 如何设置默认值
	- 通过函数原型来设置，也就是在定义函数的时候就给定一个值
	- 例如：`int add(int a = 1,int b = 2)`
		- 如果调用了这个函数，但是没有提供任何值，那么调用`add()`时，默认为`add(1,2)`
		- 如果提供了数值，那么将会覆盖默认值

<br>

# 函数重载

- 简要介绍：函数多态（函数重载）是C++在C语言基础上新增的功能，**函数重载使得我们可以使用多个同名的函数**，由此，我们可以设计一系列函数，使他们完成相同的工作，但是用不同的参数列表 

<br>

- C++只用上下文来确定要使用的函数重载版本

<br>

- 函数重载的关键是函数的**参数列表**，也就是**函数特征标**
	- **如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则两函数的特征标相同**，变量名无关紧要
	- C++允许的定义名称相同的函数，***条件是他们的特征标不同***
	- 若参数数目和/或参数类型不同，则特征标不同
	- 编译器将类型引用和类型本身视为同一个特征标
		- 例如：`double &a`和`double a`为同一种特征标

>[!Tip] 什么时候使用函数重载
>当函数基本执行相同任务，但使用不同形式的数据时

### 补充内容

- C++不允许以这种方式重载函数：
	- 对于`long gronk(int n,float m)`，进行重载`double gronk(int n,float m)`，是不允许的

<br>

- **名称修饰（名称矫正）**
	- 名称修饰是编译器在编译过程中对函数、变量、类等标识符进行改编的一种技术

<br>

- 与函数重载类似的还有运算符重载，具体参见[[C++类]]

# 函数模板

- 简要介绍：函数模板是通用的函数描述，使用泛式来定义函数
	- 该特性允许编写与数据类型无关的代码，从而实现代码复用和类型安全 

<br>

- 通过将类型作为参数传递给模板，可以使得编译器生成该类型的函数

<br>

- 创建函数模板
	- <kbd>template</kbd>和<kbd>typename</kbd>关键字是必需的
	- 例如：`template <typename AnyType>`，其中`AnyType`是创建的类型名
		- 由上述例子可知，该定义使得`AnyType`变得和`int`类似，是一个数据类型，后续是将其视为数据类型的占位符
	- 可以使用关键字<kbd>class</kbd>来代替<kbd>typename</kbd> 
		- 例如：`template <class T>` == `template <typename T>`
		- 这两者在大部分情况下几乎等价，在C++17标准之前使用<kbd>class</kbd>来声明模板参数，而在C++17之后开始引入<kbd>typename</kbd>关键字
	- 在定义函数模板的时候，需要在**声明函数原型之前定义模板函数**，还需要**在定义函数之前定义函数模板**

<br>

下面是一个例子，演示函数模板的用处，以及为何使用函数模板：

```cpp
#include <iostream>
using namespace std;
template <class T>
void myswap(T &n1,T &n2);
int main()
{
	int a = 0,b = 0;
	double A = 0,B = 0;
	cout<<"输入两个整数"<<endl;
	cin>>a>>b;
	myswap(a,b);
	cout<<"交换之后为a = "<<a<<",b = "<<b<<endl;
	cout<<"输入两个小数"<<endl;
	cin>>A>>B;
	myswap(A,B);
	cout<<"两个小数交换之后A = "<<A<<",B = "<<B<<endl;
	return 0;
}

template <class T>
void myswap(T &n1,T &n2)
{
	T temp = n1;
	n1 = n2;
	n2 = temp;
}
```

- 从上面的代码可以看出，我们并没有给`myswap()`函数指定一个明确的数据类型，而是使用函数模板<kbd>T</kbd>
	- 由此来看，函数模板和<kbd>auto</kbd>关键字有异曲同工之妙，可以自动适配正确的数据类型，但他们的不同之处很多，具体不在此处详述

<br>

- 重载的模板
	- 对于重载函数和函数模板可以共存
例如：
```cpp
template <class T>
void myswap(T &n1,T &n2);

//重载函数
template <class T>
void myswap(T &n1,T &n2,int a);
```

<br>

- 模板的局限性
	- 编写的函数模板可能无法处理某些类型

<br>

- **显式具体化**
	- 显式具体化允许我们对特定的数据类型或值提供特殊版本的模板
	- 如何显式具体化
		- 显式具体化的原型和定义应以`template<>`开头，并通过名称来指出类型
		- 例如：假设存在定义了一个结构名为<kbd>job</kbd>，那么，对这个<kbd>job</kbd>结构特殊处理的代码为：`template <> void Swap<job>(job &,job &);` 在之后为该函数编写具体的代码的时候，也需要写成`template <> void Swap<job>(job &,job &);`
			- 也可以写成另一种写法，省略`<job>`，例如：`template <> void Swap(job &,job &);`

<br>

- 实例化和具体化
	- 实例化是从模板生成具体代码，而具体化是提供模板的特殊实现
		- 实例化：编译器根据模板参数的实际类型，生成具体的函数或类代码的过程
		- 具体化：具体化是为特定类型提供定制化的实现，覆盖模板的默认行为
		- **实例化和具体化是互补的**
	- 显式实例化、隐式实例化和显式具体化统称为具体化



### 补充内容

- 具体化、模板函数、非模板函数的优先级
	- 显式具体化优先于常规模板，而非模板函数优先于显式具体化和常规模板

<br>

- **在同一个文件中使用同一类型的显示实例和显式具体化将会出错**

<br>

- 显式实例化和显式具体化的区别
	- 显式实例化是强制编译器为**特定类型**生成模板实例的代码，但不改变模板的默认逻辑
	- 显式具体化是为**特定类型**提供**定制化实现**，完全覆盖模板的默认逻辑。

<br>

# 部分总结与补充

对于函数重载、函数模板和函数模板重载，C++有一个定义良好的策略来决定为函数调用使用哪一个函数定义，这个过程被称为**重载解析**

<br>

下面简要介绍一下该过程是如何进行的
1. 收集候选函数
2. 筛选可行函数
3. 选择最佳可行函数
4. 处理歧义

<br>

- 用于找出“最具体的模板”的规则被称为**函数模板的部分排序规则**

<br>

- 在C++11之前，模板参数类型必须显式声明或通过函数参数推导，无法直接获得表达式的类型
	- C++11引入了新的关键字<kbd>decltype</kbd>用于在编译期获取任意表达式的类型（包括函数调用、运算结果、成员访问等）
	- 基本语法：`decltype(表达式) 变量名`，例如：`decltyep (x + y) xpy;`

<br>

- 若是直接返回，即整个函数只有`return x + y`，并且定义的时候使用的是模板函数，我们将无法判断判断`x + y`的返回类型，因为此时还未声明<kbd>x</kbd>和<kbd>y</kbd>的类型  
	- 为了处理这种状况，C++新增了一套语法
	- 例如：`auto h(int x,float y) -> double;`
	- 这种声明`->double`被称为后置返回类型，直接定义了返回类型为<kbd>double</kbd>
	- 这种语法也可以用于<kbd>decltype</kbd>
		- 例如：`auto gt(T1 x,T2 y) -> decltype(x + y);`

<br>

# Q&A

**Q1：** 如果返回类型是引用变量，那么这个返回的值是什么？ 

**A1：** 我们知道，引用变量相当于一个变量的别名，因此返回类型为引用时，返回的将是现有对象的别名，给出的数据也就是原始数据本身，未经修改的数据 

